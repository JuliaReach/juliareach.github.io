[{"authors":null,"categories":null,"content":"Born in Uruguay (Montevideo, 1988), I graduated in Physics from Univ. de la RepÃºblica (Facultad de Ciencias), and in Electrical Engineering (Facultad de IngenierÃ­a). I moved to France for a PhD in Mathematics and Informatics (Univ. Joseph Fourier, 2013-2015), writing a thesis on the quantum random walk, a mathematical model of particular interest in Quantum Computing.\nI\u0026rsquo;m a former post-doc researcher at VERIMAG laboratory of UniversitÃ© Grenoble Alpes (2016-2017), a leading French research center in embedded systems that are used in diverse disciplines such as avionics/aeronautics, space, transport, automotive, telecommunications, smart cards and consumer electronics. As an Applied Mathematician, my research has to do with developing innovative numerical tools that impact decisions regarding reliability, correctness and safety of systems. I specialize on formal verification of Cyber-Physical Systems (CPS), hybrid dynamical systems, and robustness analysis of neural networks.\nIf you are interested to discuss, get in touch! You can email me to mforets at gmail.com.\n","date":1612546162,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1612546162,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Born in Uruguay (Montevideo, 1988), I graduated in Physics from Univ. de la RepÃºblica (Facultad de Ciencias), and in Electrical Engineering (Facultad de IngenierÃ­a). I moved to France for a PhD in Mathematics and Informatics (Univ.","tags":null,"title":"Marcelo Forets","type":"authors"},{"authors":null,"categories":null,"content":"Christian Schilling is a computer scientist interested in analysis, formal verification, and synthesis of dynamical, cyber-physical, and software systems, and explainable artificial intelligence. Currently working at the University of Konstanz, Germany, received his Ph.D. degree under supervision of Andreas Podelski from the University of Freiburg, Germany, in 2018. Former postdoctoral fellow with Thomas A. Henzinger at IST Austria.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"9e56f752d974ea87219b284ef6178229","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Christian Schilling is a computer scientist interested in analysis, formal verification, and synthesis of dynamical, cyber-physical, and software systems, and explainable artificial intelligence. Currently working at the University of Konstanz, Germany, received his Ph.","tags":null,"title":"Christian Schilling","type":"authors"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"d4c9823dac39d787428220d0fd3222b2","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Daniel Freire Caporale","type":"authors"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"de191098a4a009447b88b4c020d51658","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"David P. Sanders","type":"authors"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"49330e8e0b51e25fe58a56e7557b5ccd","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Luis Benet","type":"authors"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2f0a565792c3cdcb13b95e7ca111f701","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Sebastian Guadalupe","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://juliareach.github.io/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":["Marcelo Forets"],"categories":[],"content":"\u0026laquo; WORK-IN-PROGRESS\u0026raquo;\nContext Let an initial-value problem be specified as follows:\n$$ y'(t) = f(t, y),\\qquad y(t_0) = y_0.\\qquad (1) $$ Here $y \\in \\mathbb{R}^m$ is an unknown function of time $t$.\nWe will consider a naive Julia implementation of the famous fourth-order explicit Runge-Kutta integration method. The idea is to use such method to solve (1) for the case when $y_0$ is defined symbolically in the sense that we replace $y_0$ by $y_0 + \\xi$ where $\\xi$ is a vector of $m$ \u0026ldquo;symbols\u0026rdquo;. We would like to evaluate how does the classic RK4 method propagate the $\\xi$ and see what information can be extracted from such expansion.\nIn this method, given a step size $h \u0026gt; 0$ we compute for each $n = 0, 1, 2, \\ldots, N$ a sequence $y_1, y_2, \\ldots, y_N$ using an explicit scheme of the form $y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i$, where the $k_i$ are obtained by evaluating $f(t, y)$ on intermediate points. In the case of RK4 one step of the algorithm is obtained with the following step function.\nfunction step!(f, y, n, t, h) kâ‚ = f(t[n], y[n]) kâ‚‚ = f(t[n] + h/2, y[n] + h*kâ‚/2) kâ‚ƒ = f(t[n] + h/2, y[n] + h*kâ‚‚/2) kâ‚„ = f(t[n] + h, y[n] + h*kâ‚ƒ) y[n+1] = y[n] + (h/6) * (kâ‚ + 2kâ‚‚ + 2kâ‚ƒ + kâ‚„) t[n+1] = t[n] + h end  step! (generic function with 1 method)  function solve(f, h, tâ‚€, T, yâ‚€) N = round(Int, (T - tâ‚€) / h) t = Vector{Float64}(undef, N) y = Vector{typeof(yâ‚€)}(undef, N) y[1] = yâ‚€; t[1] = tâ‚€; for n in 1:N-1 step!(f, y, n, t, h) end y, t end  solve (generic function with 1 method)  Example Consider the quadratic ODE\n$$ y'(t) = 1 - y^2,\\qquad y(t_0) = 0,~~ t \\in [0, 10]. $$\nWe consider a step size $h = 0.01$.\nf_quad(t, y) = 1 - y^2  f_quad (generic function with 1 method)  r, t = solve(f_quad, 0.01, 0.0, 10.0, 0.0);  using Plots  plot(t, r, seriestype=:line, lab=\u0026quot;\u0026quot;, xlab=\u0026quot;t\u0026quot;, ylab=\u0026quot;y(t)\u0026quot;)  Now suppose that we solve the recurrence with an initial state $u_0 + \\xi$.\nusing TaylorSeries  Î¾ = Taylor1(20) set_taylor1_varname(\u0026quot;Î¾\u0026quot;) u0 = 0.0 u0Î¾ = u0 + Î¾   1.0 Î¾ + ğ’ª(Î¾Â²Â¹)  y, t = solve(f_quad, 0.01, 0.0, 10.0, u0Î¾); length(y)  1000  y[1]   1.0 Î¾ + ğ’ª(Î¾Â²Â¹)  y[2]   0.009999666679166094 + 0.99990000666625 Î¾ - 0.009998666787493126 Î¾Â² + 9.998333499990624e-5 Î¾Â³ - 9.997958521864687e-7 Î¾â´ + 9.997916857282813e-9 Î¾âµ - 9.581395992702446e-11 Î¾â¶ + 8.331729276038803e-13 Î¾â· - 6.821796933983367e-15 Î¾â¸ + 4.8430989824216484e-17 Î¾â¹ - 2.968450528059874e-19 Î¾Â¹â° + 1.5103098972005213e-21 Î¾Â¹Â¹ - 6.119511719889326e-24 Î¾Â¹Â² + 1.9530794270833342e-26 Î¾Â¹Â³ - 4.557259114583335e-29 Î¾Â¹â´ + 6.510416666666671e-32 Î¾Â¹âµ - 4.069010416666671e-35 Î¾Â¹â¶ + ğ’ª(Î¾Â²Â¹)  y[3]   0.019997333758263312 + 0.9996001066422828 Î¾ - 0.019989336973987328 Î¾Â² + 0.0003997334431869484 Î¾Â³ - 7.993594720222507e-6 Î¾â´ + 1.5985124640472037e-7 Î¾âµ - 3.1883090638671063e-9 Î¾â¶ + 6.325950825886493e-11 Î¾â· - 1.2462287616432512e-12 Î¾â¸ + 2.4312653056785857e-14 Î¾â¹ - 4.687998642014969e-16 Î¾Â¹â° + 8.919632391826903e-18 Î¾Â¹Â¹ - 1.672458814319322e-19 Î¾Â¹Â² + 3.08748726849809e-21 Î¾Â¹Â³ - 5.608112595223544e-23 Î¾Â¹â´ + 1.0018858671317283e-24 Î¾Â¹âµ - 1.7600522287738262e-26 Î¾Â¹â¶ + 3.040358425374431e-28 Î¾Â¹â· - 5.164849498520435e-30 Î¾Â¹â¸ + 8.629961159714198e-32 Î¾Â¹â¹ - 1.4187146313423383e-33 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)  y[4]   0.029991003236316215 + 0.9991005397242128 Î¾ - 0.02996402754525644 Î¾Â² + 0.000898651247751589 Î¾Â³ - 2.6951439926918567e-5 Î¾â´ + 8.083018387635607e-7 Î¾âµ - 2.4229420975103902e-8 Î¾â¶ + 7.255492265663734e-10 Î¾â· - 2.169261345744115e-11 Î¾â¸ + 6.471370059589956e-13 Î¾â¹ - 1.9250541717144024e-14 Î¾Â¹â° + 5.706694617811968e-16 Î¾Â¹Â¹ - 1.6849037837381005e-17 Î¾Â¹Â² + 4.952171150219145e-19 Î¾Â¹Â³ - 1.4482976068740724e-20 Î¾Â¹â´ + 4.213120613390775e-22 Î¾Â¹âµ - 1.2187249982451306e-23 Î¾Â¹â¶ + 3.504794249260267e-25 Î¾Â¹â· - 1.0018397840714965e-26 Î¾Â¹â¸ + 2.846156443714574e-28 Î¾Â¹â¹ - 8.035424335081523e-30 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)  y[5]   0.03997868030782012 + 0.9984017051196238 Î¾ - 0.03991478262103181 Î¾Â² + 0.0015957403355221493 Î¾Â³ - 6.379557597746384e-5 Î¾â´ + 2.550464580022681e-6 Î¾âµ - 1.0194784965344293e-7 Î¾â¶ + 4.073770468253297e-9 Î¾â· - 1.6270188569216327e-10 Î¾â¸ + 6.4933229278608814e-12 Î¾â¹ - 2.588889266950159e-13 Î¾Â¹â° + 1.0309124077397989e-14 Î¾Â¹Â¹ - 4.099036112193993e-16 Î¾Â¹Â² + 1.6269963041530542e-17 Î¾Â¹Â³ - 6.445181115936467e-19 Î¾Â¹â´ + 2.5476149615176444e-20 Î¾Â¹âµ - 1.0046100402336236e-21 Î¾Â¹â¶ + 3.9513947849926016e-23 Î¾Â¹â· - 1.549979598640151e-24 Î¾Â¹â¸ + 6.062710831558582e-26 Î¾Â¹â¹ - 2.3644194573304648e-27 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)  The result is a sequence of polynomials in $\\xi$. However such characterization is only useful for small deviations with respect to the initial state \u0026ndash; and we haven\u0026rsquo;t yet characterized the error of the approximation. For example, suppose that we are interested in $y(t = 1)$:\nt[100]  0.9900000000000007  y[100]   0.7573623240820949 + 0.4264023097949346 Î¾ - 0.3229410443236415 Î¾Â² + 0.24458338018660747 Î¾Â³ - 0.1852382373895675 Î¾â´ + 0.14029246208258747 Î¾âµ - 0.10625222517422822 Î¾â¶ + 0.08047143220209468 Î¾â· - 0.06094603090212832 Î¾â¸ + 0.046158227586616425 Î¾â¹ - 0.03495850249638864 Î¾Â¹â° + 0.026476252672553414 Î¾Â¹Â¹ - 0.02005211623341677 Î¾Â¹Â² + 0.015186717331102878 Î¾Â¹Â³ - 0.01150184751249755 Î¾Â¹â´ + 0.008711065944387024 Î¾Â¹âµ - 0.006597433131544507 Î¾Â¹â¶ + 0.004996647273657277 Î¾Â¹â· - 0.003784272377387678 Î¾Â¹â¸ + 0.0028660653096264452 Î¾Â¹â¹ - 0.0021706498720577556 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)  We can evaluate this result at $\\xi = 0$:\nevaluate(y[100], 0.0)  0.7573623240820949  At a value $\\xi = 0.1$\nevaluate(y[100], 0.1)  0.7970005083277867  And also an interval:\nusing IntervalArithmetic evaluate(y[100], -0.1 .. 0.1)  [0.711228, 0.800249]  Flowpipe using ReachabilityAnalysis const RA = ReachabilityAnalysis  ReachabilityAnalysis  @taylorize function _f_quad(du, u, p, t) du[1] = 1 - u[1]^2 end prob = @ivp(x' = _f_quad(x), dim=1, x(0) âˆˆ -0.1 .. 0.1); sol = RA.solve(prob, tspan=(0.0, 10.0), alg=TMJets(abs_tol=1e-12));  plot(sol, vars=(0, 1), alpha=.2) plot!(t, r, seriestype=:line, lab=\u0026quot;\u0026quot;)  R = sol(1.0)  TaylorModelReachSet{Float64}(TaylorModels.TaylorModel1{TaylorN{Float64},Float64}[ 0.7549628871907649 + 0.043003103896458415 xâ‚ - 0.0032465747475834863 xâ‚Â² + ( 0.4300310389645844 - 0.06493149495166935 xâ‚ + 0.003052819945102918 xâ‚Â²) Î¾ + ( - 0.32465747475834694 + 0.03052819945102888 xâ‚ + 0.0018836179755100605 xâ‚Â²) Î¾Â² + ( 0.101760664836763 + 0.012557453170067179 xâ‚ - 0.00480650040545221 xâ‚Â²) Î¾Â³ + ( 0.03139363292516797 - 0.024032502027261038 xâ‚ + 0.0027912209062894602 xâ‚Â²) Î¾â´ + ( - 0.048065004054522104 + 0.011164883625157804 xâ‚ + 0.0006981330083023078 xâ‚Â²) Î¾âµ + ( 0.018608139375263018 + 0.0023271100276743783 xâ‚ - 0.0020517845820511183 xâ‚Â²) Î¾â¶ + ( 0.0033244428966776847 - 0.005862241663003196 xâ‚ + 0.001163377855574074 xâ‚Â²) Î¾â· + ( - 0.007327802078754001 + 0.0029084446389351804 xâ‚ + 0.0001265493671184609 xâ‚Â²) Î¾â¸ + [-3.86101e-14, 3.14375e-14]], [0.984396, 1.02463])  tspan(R)  [0.984396, 1.02463]  Z = polynomial.(set(R))  1-element Array{Taylor1{TaylorN{Float64}},1}: 0.7549628871907649 + 0.043003103896458415 xâ‚ - 0.0032465747475834863 xâ‚Â² + ğ’ª(â€–xâ€–Â³) + ( 0.4300310389645844 - 0.06493149495166935 xâ‚ + 0.003052819945102918 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾ + ( - 0.32465747475834694 + 0.03052819945102888 xâ‚ + 0.0018836179755100605 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾Â² + ( 0.101760664836763 + 0.012557453170067179 xâ‚ - 0.00480650040545221 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾Â³ + ( 0.03139363292516797 - 0.024032502027261038 xâ‚ + 0.0027912209062894602 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â´ + ( - 0.048065004054522104 + 0.011164883625157804 xâ‚ + 0.0006981330083023078 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾âµ + ( 0.018608139375263018 + 0.0023271100276743783 xâ‚ - 0.0020517845820511183 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â¶ + ( 0.0033244428966776847 - 0.005862241663003196 xâ‚ + 0.001163377855574074 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â· + ( - 0.007327802078754001 + 0.0029084446389351804 xâ‚ + 0.0001265493671184609 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â¸ + ğ’ª(Î¾â¹)  using LazySets using LazySets: Interval  out = [Singleton([ti]) Ã— Interval(evaluate(yi, -0.1 .. 0.1)) for (ti, yi) in zip(t, y)];  plot(out, marker=:x)  plot!(sol, vars=(0, 1), alpha=.2)  plot(sol[1:30], vars=(0, 1), alpha=.2, c=:lightblue) plot!(out[1:100], marker=:x, c=:red)  ","date":1612546162,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612546162,"objectID":"5c2133a1cdc2fd27a97bc3ffa27f407b","permalink":"https://juliareach.github.io/post/rk4_taylorseries/","publishdate":"2021-02-05T14:29:22-03:00","relpermalink":"/post/rk4_taylorseries/","section":"post","summary":"\u0026laquo; WORK-IN-PROGRESS\u0026raquo;\nContext Let an initial-value problem be specified as follows:\n$$ y'(t) = f(t, y),\\qquad y(t_0) = y_0.\\qquad (1) $$ Here $y \\in \\mathbb{R}^m$ is an unknown function of time $t$.","tags":["Reachability"],"title":"Taylor expanding ODE solutions","type":"post"},{"authors":null,"categories":null,"content":"","date":1612137600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612137600,"objectID":"959439f4ae8b854f99fb6b908943d1e5","permalink":"https://juliareach.github.io/software/reachabilityanalysis/","publishdate":"2021-02-01T00:00:00Z","relpermalink":"/software/reachabilityanalysis/","section":"software","summary":"Methods to compute sets of states reachable by dynamical systems","tags":null,"title":"ReachabilityAnalysis.jl","type":"software"},{"authors":null,"categories":null,"content":"","date":1611705600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611705600,"objectID":"8b6a24b92a56d8dfa76fec77371c89b4","permalink":"https://juliareach.github.io/software/lazysets/","publishdate":"2021-01-27T00:00:00Z","relpermalink":"/software/lazysets/","section":"software","summary":"A Julia package for calculus with convex sets","tags":null,"title":"LazySets.jl","type":"software"},{"authors":null,"categories":null,"content":"Publication Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions. Marcelo Forets, Daniel Freire, Christian Schilling, 2020. arXiv: 2006.12325.\nPresented in MEMOCODE'20: 18th ACM-IEEE International Conference on Formal Methods and Models for System Design .\nAbstract Efficiently handling time-triggered and possibly nondeterministic switches for hybrid systems reachability is a challenging task. In this paper we focus on periodically controlled systems with fast-switching controller dynamics, which often require simulation time scales of the order of nanoseconds. Accurate set-based computations for such systems with relatively large time horizons are expensive due to the accumulation of errors in the discrete transitions. We present an approach based on conservative set-based enclosure of the dynamics that can handle systems with uncertain parameters and inputs. We demonstrate our algorithm on the plant model of an experimental electro-mechanical braking system with periodic controller.\nContributions Timed systems play an important role in modeling and analyzing cyber-physical systems. In this work we consider a class of hybrid-automaton models with continuous dynamics and time-triggered discrete events following a periodic clock. We propose a reachability framework to compute an overapproximation of the states reachable by such systems.\nConventional techniques tightly integrate the computation of the continuous behavior and the discrete events. Our approach allows to separate these concerns for the model class considered here, which simplifies the analysis drastically in practice and allows us to plug in any reachability algorithm from the literature.\nAs a case study, we consider a parametric model of a cyber-physical system consisting of an experimental electro-mechanical brake and a software-implemented periodic controller. The model was originally described in earlier work by Strathmann and Oehlerking where the authors developed a simplified version of a nonlinear system. The model is representative of real challenges in the automotive industry and allows the application of formal methods during development. Computing the reachable states for this simplified model takes twelve hours using the previous approach, and less than a minute with our approach.\nThis paper makes the following original contributions:\n  We present an efficient algorithm for deterministic periodic time-triggered hybrid systems with uncertain parameters of the system dynamics or the initial conditions.\n  We extend the algorithm to the more difficult and new scenario of nondeterministic periodic discrete switches.\n  We demonstrate the efficiency of our algorithm on a model of an electro-mechanical brake system.\n  Presentation   Presentation slides (pdf) are available here.\n  A short video for MEMOCODE'20 is available here.\n  How to cite @article{forets2020efficient, title={Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions}, author={Forets, Marcelo and Freire, Daniel and Schilling, Christian}, journal={arXiv preprint arXiv:2006.12325}, year={2020} }  ","date":1590969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590969600,"objectID":"62385185e2434755413066a027acea84","permalink":"https://juliareach.github.io/project/timetrigger/","publishdate":"2020-06-01T00:00:00Z","relpermalink":"/project/timetrigger/","section":"project","summary":"by Marcelo Forets, Daniel Freire, Christian Schilling, 2020.","tags":["Reachability","Hybrid systems","Periodic controller"],"title":"Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions","type":"project"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"88872e52325d54ded5a39acf8e365fd8","permalink":"https://juliareach.github.io/software/rangeenclosures/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/software/rangeenclosures/","section":"software","summary":"A Julia package to compute Bernstein coefficients of multivariate polynomials","tags":null,"title":"RangeEnclosures.jl","type":"software"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"c1cb1c54d86495d4636fada5a395688a","permalink":"https://juliareach.github.io/software/reachabilitymodels/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/software/reachabilitymodels/","section":"software","summary":"A library of reachability models","tags":null,"title":"ReachabilityModels.jl","type":"software"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://juliareach.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"7aaf37253d7268ccc83f51209d22a65b","permalink":"https://juliareach.github.io/software/neuralnetworkanalysis/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/software/neuralnetworkanalysis/","section":"software","summary":"Methods to verify neural network control systems using reachability analysis","tags":null,"title":"NeuralNetworkAnalysis.jl","type":"software"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"fc40296106e4609cf2e8e77b9e55bc41","permalink":"https://juliareach.github.io/software/mathematicalsystems/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/software/mathematicalsystems/","section":"software","summary":"Systems definitions in Julia","tags":null,"title":"MathematicalSystems.jl","type":"software"},{"authors":null,"categories":null,"content":"","date":1136073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1136073600,"objectID":"3bf56fe54fe6b655748274956cb421c0","permalink":"https://juliareach.github.io/software/bernsteinexpansions/","publishdate":"2006-01-01T00:00:00Z","relpermalink":"/software/bernsteinexpansions/","section":"software","summary":"A Julia package to compute Bernstein coefficients of multivariate polynomials","tags":null,"title":"BernsteinExpansions.jl","type":"software"},{"authors":null,"categories":null,"content":"","date":1104537600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1104537600,"objectID":"5ee385644754194fea39a234f4e8ca11","permalink":"https://juliareach.github.io/software/mathematicalpredicates/","publishdate":"2005-01-01T00:00:00Z","relpermalink":"/software/mathematicalpredicates/","section":"software","summary":"Predicate definitions in Julia","tags":null,"title":"MathematicalPredicates.jl","type":"software"}]