<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reachability | JuliaReach</title>
    <link>https://juliareach.github.io/tag/reachability/</link>
      <atom:link href="https://juliareach.github.io/tag/reachability/index.xml" rel="self" type="application/rss+xml" />
    <description>Reachability</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021 JuliaReach Developers</copyright><lastBuildDate>Fri, 05 Feb 2021 14:29:22 -0300</lastBuildDate>
    <image>
      <url>https://juliareach.github.io/media/JuliaReach_ISOLOGO_vertical.jpg</url>
      <title>Reachability</title>
      <link>https://juliareach.github.io/tag/reachability/</link>
    </image>
    
    <item>
      <title>Taylor expanding ODE solutions</title>
      <link>https://juliareach.github.io/post/rk4_taylorseries/</link>
      <pubDate>Fri, 05 Feb 2021 14:29:22 -0300</pubDate>
      <guid>https://juliareach.github.io/post/rk4_taylorseries/</guid>
      <description>&lt;p&gt;&amp;laquo; WORK-IN-PROGRESS&amp;raquo;&lt;/p&gt;
&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;
&lt;p&gt;Let an initial-value problem be specified as follows:&lt;/p&gt;
&lt;p&gt;$$
y&#39;(t) = f(t, y),\qquad y(t_0) = y_0.\qquad (1)
$$
Here $y \in \mathbb{R}^m$ is an unknown function of time $t$.&lt;/p&gt;
&lt;p&gt;We will consider a naive Julia implementation of the famous fourth-order explicit &lt;a href=&#34;https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Runge-Kutta integration method&lt;/a&gt;. The idea is to use such method to solve (1) for the case when $y_0$ is defined symbolically in the sense that we replace $y_0$ by $y_0 + \xi$ where $\xi$ is a vector of $m$ &amp;ldquo;symbols&amp;rdquo;. We would like to evaluate how does the classic RK4 method propagate the $\xi$ and see what information can be extracted from such expansion.&lt;/p&gt;
&lt;p&gt;In this method, given a step size $h &amp;gt; 0$ we compute for each $n = 0, 1, 2, \ldots, N$ a sequence $y_1, y_2, \ldots, y_N$ using an explicit scheme of the form $y_{n+1} = y_n + h \sum_{i=1}^s b_i k_i$, where the $k_i$ are obtained by evaluating $f(t, y)$ on intermediate points. In the case of RK4 one step of the algorithm is obtained with the following &lt;code&gt;step&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function step!(f, y, n, t, h)
    kâ‚ = f(t[n], y[n])
    kâ‚‚ = f(t[n] + h/2, y[n] + h*kâ‚/2)
    kâ‚ƒ = f(t[n] + h/2, y[n] + h*kâ‚‚/2)
    kâ‚„ = f(t[n] + h, y[n] + h*kâ‚ƒ)

    y[n+1] = y[n] + (h/6) * (kâ‚ + 2kâ‚‚ + 2kâ‚ƒ + kâ‚„)
    t[n+1] = t[n] + h
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;step! (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function solve(f, h, tâ‚€, T, yâ‚€)
    N = round(Int, (T - tâ‚€) / h)
    t = Vector{Float64}(undef, N)
    y = Vector{typeof(yâ‚€)}(undef, N)
    y[1] = yâ‚€; t[1] = tâ‚€;

    for n in 1:N-1
        step!(f, y, n, t, h)
    end
    y, t
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;solve (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;Consider the quadratic ODE&lt;/p&gt;
&lt;p&gt;$$
y&#39;(t) = 1 - y^2,\qquad y(t_0) = 0,~~ t \in [0, 10].
$$&lt;/p&gt;
&lt;p&gt;We consider a step size $h = 0.01$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;f_quad(t, y) = 1 - y^2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;f_quad (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;r, t = solve(f_quad, 0.01, 0.0, 10.0, 0.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using Plots
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot(t, r, seriestype=:line, lab=&amp;quot;&amp;quot;, xlab=&amp;quot;t&amp;quot;, ylab=&amp;quot;y(t)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_12_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now suppose that we solve the recurrence with an initial state $u_0 + \xi$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using TaylorSeries
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Î¾ = Taylor1(20)
set_taylor1_varname(&amp;quot;Î¾&amp;quot;)
u0 = 0.0
u0Î¾ = u0 + Î¾
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 1.0 Î¾ + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y, t = solve(f_quad, 0.01, 0.0, 10.0, u0Î¾);

length(y)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 1.0 Î¾ + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 0.009999666679166094 + 0.99990000666625 Î¾ - 0.009998666787493126 Î¾Â² + 9.998333499990624e-5 Î¾Â³ - 9.997958521864687e-7 Î¾â´ + 9.997916857282813e-9 Î¾âµ - 9.581395992702446e-11 Î¾â¶ + 8.331729276038803e-13 Î¾â· - 6.821796933983367e-15 Î¾â¸ + 4.8430989824216484e-17 Î¾â¹ - 2.968450528059874e-19 Î¾Â¹â° + 1.5103098972005213e-21 Î¾Â¹Â¹ - 6.119511719889326e-24 Î¾Â¹Â² + 1.9530794270833342e-26 Î¾Â¹Â³ - 4.557259114583335e-29 Î¾Â¹â´ + 6.510416666666671e-32 Î¾Â¹âµ - 4.069010416666671e-35 Î¾Â¹â¶ + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 0.019997333758263312 + 0.9996001066422828 Î¾ - 0.019989336973987328 Î¾Â² + 0.0003997334431869484 Î¾Â³ - 7.993594720222507e-6 Î¾â´ + 1.5985124640472037e-7 Î¾âµ - 3.1883090638671063e-9 Î¾â¶ + 6.325950825886493e-11 Î¾â· - 1.2462287616432512e-12 Î¾â¸ + 2.4312653056785857e-14 Î¾â¹ - 4.687998642014969e-16 Î¾Â¹â° + 8.919632391826903e-18 Î¾Â¹Â¹ - 1.672458814319322e-19 Î¾Â¹Â² + 3.08748726849809e-21 Î¾Â¹Â³ - 5.608112595223544e-23 Î¾Â¹â´ + 1.0018858671317283e-24 Î¾Â¹âµ - 1.7600522287738262e-26 Î¾Â¹â¶ + 3.040358425374431e-28 Î¾Â¹â· - 5.164849498520435e-30 Î¾Â¹â¸ + 8.629961159714198e-32 Î¾Â¹â¹ - 1.4187146313423383e-33 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[4]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 0.029991003236316215 + 0.9991005397242128 Î¾ - 0.02996402754525644 Î¾Â² + 0.000898651247751589 Î¾Â³ - 2.6951439926918567e-5 Î¾â´ + 8.083018387635607e-7 Î¾âµ - 2.4229420975103902e-8 Î¾â¶ + 7.255492265663734e-10 Î¾â· - 2.169261345744115e-11 Î¾â¸ + 6.471370059589956e-13 Î¾â¹ - 1.9250541717144024e-14 Î¾Â¹â° + 5.706694617811968e-16 Î¾Â¹Â¹ - 1.6849037837381005e-17 Î¾Â¹Â² + 4.952171150219145e-19 Î¾Â¹Â³ - 1.4482976068740724e-20 Î¾Â¹â´ + 4.213120613390775e-22 Î¾Â¹âµ - 1.2187249982451306e-23 Î¾Â¹â¶ + 3.504794249260267e-25 Î¾Â¹â· - 1.0018397840714965e-26 Î¾Â¹â¸ + 2.846156443714574e-28 Î¾Â¹â¹ - 8.035424335081523e-30 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[5]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 0.03997868030782012 + 0.9984017051196238 Î¾ - 0.03991478262103181 Î¾Â² + 0.0015957403355221493 Î¾Â³ - 6.379557597746384e-5 Î¾â´ + 2.550464580022681e-6 Î¾âµ - 1.0194784965344293e-7 Î¾â¶ + 4.073770468253297e-9 Î¾â· - 1.6270188569216327e-10 Î¾â¸ + 6.4933229278608814e-12 Î¾â¹ - 2.588889266950159e-13 Î¾Â¹â° + 1.0309124077397989e-14 Î¾Â¹Â¹ - 4.099036112193993e-16 Î¾Â¹Â² + 1.6269963041530542e-17 Î¾Â¹Â³ - 6.445181115936467e-19 Î¾Â¹â´ + 2.5476149615176444e-20 Î¾Â¹âµ - 1.0046100402336236e-21 Î¾Â¹â¶ + 3.9513947849926016e-23 Î¾Â¹â· - 1.549979598640151e-24 Î¾Â¹â¸ + 6.062710831558582e-26 Î¾Â¹â¹ - 2.3644194573304648e-27 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is a sequence of polynomials in $\xi$. However such characterization is only useful for small deviations with respect to the initial state &amp;ndash; and we haven&amp;rsquo;t yet characterized the error of the approximation. For example, suppose that we are interested in $y(t = 1)$:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;t[100]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.9900000000000007
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;y[100]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; 0.7573623240820949 + 0.4264023097949346 Î¾ - 0.3229410443236415 Î¾Â² + 0.24458338018660747 Î¾Â³ - 0.1852382373895675 Î¾â´ + 0.14029246208258747 Î¾âµ - 0.10625222517422822 Î¾â¶ + 0.08047143220209468 Î¾â· - 0.06094603090212832 Î¾â¸ + 0.046158227586616425 Î¾â¹ - 0.03495850249638864 Î¾Â¹â° + 0.026476252672553414 Î¾Â¹Â¹ - 0.02005211623341677 Î¾Â¹Â² + 0.015186717331102878 Î¾Â¹Â³ - 0.01150184751249755 Î¾Â¹â´ + 0.008711065944387024 Î¾Â¹âµ - 0.006597433131544507 Î¾Â¹â¶ + 0.004996647273657277 Î¾Â¹â· - 0.003784272377387678 Î¾Â¹â¸ + 0.0028660653096264452 Î¾Â¹â¹ - 0.0021706498720577556 Î¾Â²â° + ğ’ª(Î¾Â²Â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can evaluate this result at $\xi = 0$:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;evaluate(y[100], 0.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.7573623240820949
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At a value $\xi = 0.1$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;evaluate(y[100], 0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.7970005083277867
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And also an interval:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using IntervalArithmetic

evaluate(y[100], -0.1 .. 0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.711228, 0.800249]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flowpipe&#34;&gt;Flowpipe&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using ReachabilityAnalysis
const RA = ReachabilityAnalysis
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ReachabilityAnalysis
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@taylorize function _f_quad(du, u, p, t)
    du[1] = 1 - u[1]^2
end
prob = @ivp(x&#39; = _f_quad(x), dim=1, x(0) âˆˆ -0.1 .. 0.1);
sol = RA.solve(prob, tspan=(0.0, 10.0), alg=TMJets(abs_tol=1e-12));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot(sol, vars=(0, 1), alpha=.2)
plot!(t, r, seriestype=:line, lab=&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_34_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;R = sol(1.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;TaylorModelReachSet{Float64}(TaylorModels.TaylorModel1{TaylorN{Float64},Float64}[  0.7549628871907649 + 0.043003103896458415 xâ‚ - 0.0032465747475834863 xâ‚Â² + ( 0.4300310389645844 - 0.06493149495166935 xâ‚ + 0.003052819945102918 xâ‚Â²) Î¾ + ( - 0.32465747475834694 + 0.03052819945102888 xâ‚ + 0.0018836179755100605 xâ‚Â²) Î¾Â² + ( 0.101760664836763 + 0.012557453170067179 xâ‚ - 0.00480650040545221 xâ‚Â²) Î¾Â³ + ( 0.03139363292516797 - 0.024032502027261038 xâ‚ + 0.0027912209062894602 xâ‚Â²) Î¾â´ + ( - 0.048065004054522104 + 0.011164883625157804 xâ‚ + 0.0006981330083023078 xâ‚Â²) Î¾âµ + ( 0.018608139375263018 + 0.0023271100276743783 xâ‚ - 0.0020517845820511183 xâ‚Â²) Î¾â¶ + ( 0.0033244428966776847 - 0.005862241663003196 xâ‚ + 0.001163377855574074 xâ‚Â²) Î¾â· + ( - 0.007327802078754001 + 0.0029084446389351804 xâ‚ + 0.0001265493671184609 xâ‚Â²) Î¾â¸ + [-3.86101e-14, 3.14375e-14]], [0.984396, 1.02463])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;tspan(R)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.984396, 1.02463]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Z = polynomial.(set(R))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1-element Array{Taylor1{TaylorN{Float64}},1}:
   0.7549628871907649 + 0.043003103896458415 xâ‚ - 0.0032465747475834863 xâ‚Â² + ğ’ª(â€–xâ€–Â³) + ( 0.4300310389645844 - 0.06493149495166935 xâ‚ + 0.003052819945102918 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾ + ( - 0.32465747475834694 + 0.03052819945102888 xâ‚ + 0.0018836179755100605 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾Â² + ( 0.101760664836763 + 0.012557453170067179 xâ‚ - 0.00480650040545221 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾Â³ + ( 0.03139363292516797 - 0.024032502027261038 xâ‚ + 0.0027912209062894602 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â´ + ( - 0.048065004054522104 + 0.011164883625157804 xâ‚ + 0.0006981330083023078 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾âµ + ( 0.018608139375263018 + 0.0023271100276743783 xâ‚ - 0.0020517845820511183 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â¶ + ( 0.0033244428966776847 - 0.005862241663003196 xâ‚ + 0.001163377855574074 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â· + ( - 0.007327802078754001 + 0.0029084446389351804 xâ‚ + 0.0001265493671184609 xâ‚Â² + ğ’ª(â€–xâ€–Â³)) Î¾â¸ + ğ’ª(Î¾â¹)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using LazySets
using LazySets: Interval
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;out = [Singleton([ti]) Ã— Interval(evaluate(yi, -0.1 .. 0.1)) for (ti, yi) in zip(t, y)];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot(out, marker=:x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_40_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot!(sol, vars=(0, 1), alpha=.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_41_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot(sol[1:30], vars=(0, 1), alpha=.2, c=:lightblue)
plot!(out[1:100], marker=:x, c=:red)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;output_42_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reachability analysis of linear hybrid systems via block decomposition</title>
      <link>https://juliareach.github.io/project/decohybrid/</link>
      <pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/decohybrid/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Reachability analysis aims at identifying states reachable by a system within a given time horizon. This task is known to be computationally expensive for linear hybrid systems. Reachability analysis works by iteratively applying continuous and discrete post operators to compute states reachable according to continuous and discrete dynamics, respectively. In this article, we enhance both of these operators and make sure that most of the involved computations are performed in low-dimensional state space. In particular, we improve the continuous-post operator by performing computations in high-dimensional state space only for time intervals relevant for the subsequent application of the discrete-post operator. Furthermore, the new discrete-post operator performs low-dimensional computations by leveraging the structure of the guard and assignment of a considered transition. We illustrate the potential of our approach on a number of challenging benchmarks.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;h2 id=&#34;presentation&#34;&gt;Presentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Presentation slides (pdf) are available &lt;a href=&#34;https://github.com/JuliaReach/JuliaReach-website/blob/master/Talks/DecoHybrid_EMSOFT20/DecoHybrid_EMSOFT20.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The recording for EMSOFT&#39;20 is available &lt;a href=&#34;https://www.youtube.com/watch?v=JVDRaHnSfEQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@article{forets2020efficient,
  title={Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions},
  author={Forets, Marcelo and Freire, Daniel and Schilling, Christian},
  journal={arXiv preprint arXiv:2006.12325},
  year={2020}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics</title>
      <link>https://juliareach.github.io/project/archcomp19_aff/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/archcomp19_aff/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics.&lt;/strong&gt; Matthias Althoff, Stanley Bak, Marcelo Forets, Goran Frehse, Niklas Kochdumper, Rajarshi Ray, Christian Schilling and Stefan Schupp (2019) ARCH19. 6th International Workshop on Applied Verification of Continuous and Hybrid Systems, vol 61, pages 14&amp;ndash;40 &lt;a href=&#34;https://easychair.org/publications/paper/1gbP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;doi: 10.29007/bj1w&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics</title>
      <link>https://juliareach.github.io/project/archcomp20_aff/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/archcomp20_aff/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics.&lt;/strong&gt;
Matthias Althoff, Stanley Bak, Zongnan Bao, Marcelo Forets, Daniel Freire, Goran Frehse, Niklas
Kochdumper, Yangge Li, Sayan Mitra, Rajarshi Ray, Christian Schilling, Stefan Schupp, and Mark
Wetzlinger (2020) ARCH20. 7th International Workshop on Applied Verification of Continuous and
Hybrid Systems. 7th International Workshop on Applied Verification of Continuous and Hybrid Systems
(ARCH20), vol 74, pages 16&amp;ndash;48. &lt;a href=&#34;https://easychair.org/publications/paper/DRpS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10.29007/7dt2&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;We present the results of the ARCH 2020
(&lt;a href=&#34;http://cps-vo.org/group/ARCH&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Workshop on Applied Verification for Continuous and Hybrid Systems&lt;/a&gt; friendly
competition for formal verification of continuous and hybrid systems with linear continuous dynamics.
In its fourth edition, eight tools have been applied to solve eight different benchmark problems in the
category for linear continuous dynamics (in alphabetical order): CORA, C2E2, HyDRA, Hylaa, Hylaa-Continuous,
JuliaReach, SpaceEx, and XSpeed. This report is a snapshot of the current landscape of tools and the types of
benchmarks they are particularly suited for. Due to the diversity of problems, we are not ranking tools,
yet the presented results provide one of the most complete assessments of tools for the safety verification
of continuous and hybrid systems with linear continuous dynamics up to this date.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;p&gt;We consider the verification of hybrid systems (i.e., mixed discrete/continuous systems) with linear continuous dynamics
$$
\dot{x}(t) = Ax(t) + Bu(t),
$$
where $A \in \mathbb{R}^{n \times n}$, $x \in \mathbb{R}^n$, $B \in \mathbb{R}^{n \times m}$, and $u \in \mathbb{R}^m$. For all results reported by each participant, we have run an independent repeatability evaluation. To establish further trustworthiness of the results, the code with which the results have been obtained is publicly available &lt;a href=&#34;https://gitlab.com/goranf/ARCH-COMP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.
The selection of the benchmarks has been conducted within the forum of the ARCH website
(&lt;a href=&#34;http://cps-vo.org/group/ARCH&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;), which is visible for registered users and
registration is open to anybody. All tools presented in this report use some form of
reachability analysis. This, however, is not a constraint set by the organizers of the friendly competition. We hope to encourage further tool developers to showcase their results in future editions.&lt;/p&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@inproceedings{ARCH20:ARCH_COMP20_Category_Report_Continuous,
  author    = {Matthias Althoff and Stanley Bak and Zongnan Bao and Marcelo Forets and Goran Frehse and Daniel Freire and Niklas Kochdumper and Yangge Li and Sayan Mitra and Rajarshi Ray and Christian Schilling and Stefan Schupp and Mark Wetzlinger},
  title     = {ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics},
  booktitle = {ARCH20. 7th International Workshop on Applied Verification of Continuous and Hybrid Systems (ARCH20)},
  editor    = {Goran Frehse and Matthias Althoff},
  series    = {EPiC Series in Computing},
  volume    = {74},
  pages     = {16--48},
  year      = {2020},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/DRpS},
  doi       = {10.29007/7dt2}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics</title>
      <link>https://juliareach.github.io/project/archcomp20_nln/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/archcomp20_nln/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics.&lt;/strong&gt; Luca Geretti, Julien Alexandre dit Sandretto, Matthias Althoff, Luis Benet, Alexandre Chapoutot, Xin Chen, Pieter Collins, Marcelo Forets, Daniel Freire, Fabian Immler, Niklas Kochdumper, David P. Sanders and Christian
Schilling (2020) ARCH20. To appear in 7th International Workshop on Applied Verification of Continuous and Hybrid Systems. 7th International Workshop on Applied Verification of Continuous and Hybrid Systems (ARCH20), vol 74, pages 49&amp;ndash;75. &lt;a href=&#34;https://easychair.org/publications/paper/nrdD&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10.29007/zkf6&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;We present the results of a friendly competition for formal verification of continuous and hybrid
systems with nonlinear continuous dynamics. The friendly competition took place as part of the
workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2020. This year, 6 tools
Ariadne, CORA, DynIbex, Flow*, Isabelle/HOL, and JuliaReach (in alphabetic order) participated.
These tools are applied to solve reachability analysis problems on six benchmark problems, two of them
featuring hybrid dynamics. We do not rank the tools based on the results, but show the current status
and discover the potential advantages of different tools.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;p&gt;In this report, we summarize the results of the fourth ARCH friendly competition on the
reachability analysis of continuous and hybrid systems with nonlinear dynamics. Given a system
defined by a nonlinear Ordinary Differential Equation (ODE) $\dot{x} = f(x, t)$ along with an initial
condition $x \in X_0$, we apply the participating tools to prove properties of the state reachable set
in a bounded time horizon. The techniques for solving such a problem are usually very sensitive
to not only the nonlinearity of the dynamics but also the size of the initial set. This is also one
of the main reasons why most of the tools require quite a lot of computational parameters.
In this report, 6 tools Ariadne, CORA, DynIbex, Flow*, Isabelle/HOL, and JuliaReach
participated in solving problems defined on four continuous and two hybrid benchmarks. The
continuous benchmarks are the Production-Destruction system, the Coupled Van der Pol os-
cillator, the Laub-Loomis model, and a controlled Quadrotor model. The hybrid benchmarks
model a Lotka-Volterra system with a Tangential Crossing, and a Space Rendezvous system.&lt;/p&gt;
&lt;p&gt;For the 2020 edition of the competition we introduced two new benchmarks: the Production-
Destruction system and the Lotka-Volterra system with tangential crossing. The former is a
continuous system aimed at identifying the stability of integration schemes. The latter intro-
duces nonlinear guards and in particular tangential crossings. In addition, we extended the van
der Pol oscillator to two coupled oscillators, introduced nondeterministic crossing in the Space
Rendezvous system and performed some input sensitivity analysis for the Quadrotor system.
The Laub-Loomis benchmark was not modified, in order to perform a direct comparison with
results from the previous year (since the participants are the same).&lt;/p&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@inproceedings{ARCH20:ARCH_COMP20_Category_Report_Continuous,
  author    = {Luca Geretti and Julien Alexandre Dit Sandretto and Matthias Althoff and Luis Benet and Alexandre Chapoutot and Xin Chen and Pieter Collins and Marcelo Forets and Daniel Freire and Fabian Immler and Niklas Kochdumper and David P. Sanders and Christian Schilling},
  title     = {ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics},
  booktitle = {ARCH20. 7th International Workshop on Applied Verification of Continuous and Hybrid Systems (ARCH20)},
  editor    = {Goran Frehse and Matthias Althoff},
  series    = {EPiC Series in Computing},
  volume    = {74},
  pages     = {49--75},
  year      = {2020},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/nrdD},
  doi       = {10.29007/zkf6}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions</title>
      <link>https://juliareach.github.io/project/timetrigger/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/timetrigger/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions.&lt;/strong&gt; Marcelo Forets, Daniel Freire, Christian Schilling, 2020. &lt;a href=&#34;https://arxiv.org/abs/2006.12325&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;arXiv: 2006.12325&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Presented in MEMOCODE&#39;20: &lt;a href=&#34;https://iitjammu.ac.in/conferences/memocode2020/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;18th ACM-IEEE International Conference on Formal Methods and Models for System Design
&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Efficiently handling time-triggered and possibly nondeterministic switches for hybrid systems
reachability is a challenging task. In this paper we focus on periodically controlled systems
with fast-switching controller dynamics, which often require simulation time scales of the order
of nanoseconds. Accurate set-based computations for such systems with relatively large time
horizons are expensive due to the accumulation of errors in the discrete transitions.
We present an approach based on conservative set-based enclosure of the dynamics that can handle systems
with uncertain parameters and inputs. We demonstrate our algorithm on the plant model of an
experimental electro-mechanical braking system with periodic controller.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;p&gt;Timed systems play an important role in modeling and analyzing cyber-physical systems.
In this work we consider a class of hybrid-automaton models with continuous dynamics and time-triggered discrete events following a periodic clock.
We propose a reachability framework to compute an overapproximation of the states reachable by such systems.&lt;/p&gt;
&lt;p&gt;Conventional techniques tightly integrate the computation of the continuous behavior and the discrete events.
Our approach allows to separate these concerns for the model class considered here, which simplifies
the analysis drastically in practice and allows us to plug in any reachability algorithm from the literature.&lt;/p&gt;
&lt;p&gt;As a case study, we consider a parametric model of a cyber-physical system consisting of an experimental
electro-mechanical brake and a software-implemented periodic controller.
The model was originally described in earlier work by Strathmann and Oehlerking where the
authors developed a simplified version of a nonlinear system.
The model is representative of real challenges in the automotive industry and allows the application of formal methods during development.
Computing the reachable states for this simplified model takes twelve hours using the previous
approach, and less than a minute with our approach.&lt;/p&gt;
&lt;p&gt;This paper makes the following original contributions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We present an efficient algorithm for deterministic periodic time-triggered hybrid systems with &lt;strong&gt;uncertain parameters&lt;/strong&gt; of the system dynamics or the initial conditions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We extend the algorithm to the more difficult and new scenario of &lt;strong&gt;nondeterministic periodic&lt;/strong&gt; discrete switches.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We demonstrate the &lt;strong&gt;efficiency&lt;/strong&gt; of our algorithm on a model of an electro-mechanical brake system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;presentation&#34;&gt;Presentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Presentation slides (pdf) are available &lt;a href=&#34;https://github.com/JuliaReach/JuliaReach-website/tree/master/Talks/EMBrake_MEMOCODE20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A short video for MEMOCODE&#39;20 is available &lt;a href=&#34;https://www.youtube.com/watch?v=n9ZNZmL1tlw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@article{forets2020efficient,
  title={Efficient reachability analysis of parametric linear hybrid systems with time-triggered transitions},
  author={Forets, Marcelo and Freire, Daniel and Schilling, Christian},
  journal={arXiv preprint arXiv:2006.12325},
  year={2020}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics</title>
      <link>https://juliareach.github.io/project/archcomp19_nln/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/archcomp19_nln/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics.&lt;/strong&gt;
Fabian Immler, Matthias Althoff, Luis Benet,
Alexandre Chapoutot, Xin Chen, Marcelo Forets,
Luca Geretti, Niklas Kochdumper,
David P. Sanders and Christian Schilling (2019)
ARCH19. 6th International Workshop on Applied
Verification of Continuous and Hybrid Systems,
vol 61, pages 41&amp;ndash;61
&lt;a href=&#34;https://easychair.org/publications/paper/1gbP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;doi: 10.29007/bj1w&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JuliaReach: a Toolbox for Set-Based Reachability</title>
      <link>https://juliareach.github.io/project/juliareachtoolbox/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/juliareachtoolbox/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JuliaReach: a Toolbox for Set-Based Reachability.&lt;/strong&gt; Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Kostiantyn Potomkin, Christian Schilling. Published in Proceedings of &lt;a href=&#34;http://hscc2019.eecs.umich.edu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HSCC&#39;19&lt;/a&gt;: 22nd ACM International Conference on Hybrid Systems: Computation and Control (HSCC&#39;19), see &lt;a href=&#34;https://dl.acm.org/citation.cfm?id=3311804&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ACM link here&lt;/a&gt;. &lt;a href=&#34;https://arxiv.org/abs/1901.10736&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get pdf from arXiv: 1901.10736&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;We present JuliaReach, a toolbox for set-based
reachability analysis of dynamical systems.
JuliaReach consists of two main packages: Reachability, containing implementations
of reachability algorithms for continuous
and hybrid systems, and LazySets, a
standalone library that implements
state-of-the-art algorithms for calculus
with convex sets. The library offers both
concrete and lazy set representations, where
the latter stands for the ability to delay
set computations until they are needed. The
choice of the programming language Julia and
the accompanying documentation of our
toolbox allow researchers to easily translate
set-based algorithms from mathematics to
software in a platform-independent way,
while achieving runtime performance that
is comparable to statically compiled languages.
Combining lazy operations in high dimensions
and explicit computations in low dimensions,
JuliaReach can be applied to solve complex,
large-scale problems.&lt;/p&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@inproceedings{bogomolov2019juliareach,
  title={JuliaReach: a toolbox for set-based reachability},
  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Potomkin, Kostiantyn and Schilling, Christian},
  booktitle={Proceedings of the 22nd ACM International Conference on Hybrid Systems: Computation and Control},
  pages={39--44},
  year={2019}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ARCH-COMP18 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics</title>
      <link>https://juliareach.github.io/project/archcomp18_aff/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/archcomp18_aff/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ARCH-COMP18 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics.&lt;/strong&gt;
Matthias Althoff, Stanley Bak, Xin Chen, Chuchu Fan, Marcelo Forets, Goran Frehse,
Niklas Kochdumper, Yangge Li, Sayan Mitra, Rajarshi Ray, Christian Schilling and Stefan Schupp (2018) ARCH18.
5th International Workshop on Applied Verification of Continuous and Hybrid Systems, 54: 23â€“52.
doi: &lt;a href=&#34;https://dx.doi.org/10.29007/73mb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10.29007/73mb&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This report presents the results of a friendly competition for formal verification of continuous
and hybrid systems with linear continuous dynamics. The friendly competition took place as part
of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2018.
In its second edition, 9 tools have been applied to solve six different benchmark problems
in the category for linear continuous dynamics (in alphabetical order): CORA, CORA/SX, C2E2,
Flow*, HyDRA, Hylaa, Hylaa-Continuous, JuliaReach, SpaceEx, and XSpeed.
This report is a snapshot of the current landscape of tools and the types of benchmarks
they are particularly suited for. Due to the diversity of problems, we are not ranking tools,
yet the presented results probably provide the most complete assessment of tools for
the safety verification of continuous and hybrid systems with linear continuous dynamics up to this date.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;p&gt;This report summarizes results obtained in the 2018 friendly competition of the ARCH
workshop for verifying hybrid systems with linear continuous dynamics
$$
\dot{x}(t) = Ax(t) + Bu(t),
$$
where $A \in \mathbb{R}^{n \times n}$, $x \in \mathbb{R}^n$, $B \in \mathbb{R}^{n \times m}$, and $u \in \mathbb{R}^m$.
Participating tools are summarized in
Sec. 2. The results of our selected benchmark problems are shown in Sec. 3 and are obtained
on the tool developersâ€™ own machines. Thus, one has to factor in the computational power of
the processors used, summarized in Appendix A, as well as the efficiency of the programming
language of the tools.
The goal of the friendly competition is not to rank the results, but rather to present the
landscape of existing solutions in a breadth that is not possible with scientific publications in
classical venues. Such publications would typically require the presentation of novel techniques,
while this report showcases the current state-of-the-art tools. For all results reported by each
participant, we have run an independent repeatability evaluation.
The selection of the benchmarks has been conducted within the forum of the ARCH website
(&lt;a href=&#34;cps-vo.org/group/ARCH&#34;&gt;cps-vo.org/group/ARCH&lt;/a&gt;), which is visible for registered users
and registration is open for anybody. All tools presented in this report use some form
of reachability analysis. This, however, is not a constraint set by the organizers of
the friendly competition. We hope to encourage further tool developers to showcase
their results in future editions.&lt;/p&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@inproceedings{ARCH18:ARCH_COMP18_Category_Report_Continuous,
  author    = {Matthias Althoff and Stanley Bak and Xin Chen and Chuchu Fan and Marcelo Forets and Goran Frehse and Niklas Kochdumper and Yangge Li and Sayan Mitra and Rajarshi Ray and Christian Schilling and Stefan Schupp},
  title     = {ARCH-COMP18 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics},
  booktitle = {ARCH18. 5th International Workshop on Applied Verification of Continuous and Hybrid Systems},
  editor    = {Goran Frehse},
  series    = {EPiC Series in Computing},
  volume    = {54},
  pages     = {23--52},
  year      = {2018},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/4cGr},
  doi       = {10.29007/73mb}}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices</title>
      <link>https://juliareach.github.io/project/bffpsv18/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://juliareach.github.io/project/bffpsv18/</guid>
      <description>&lt;h2 id=&#34;publication&#34;&gt;Publication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices.&lt;/strong&gt; Sergiy Bogomolov, Marcelo Forets, Goran Frehse, FrÃ©dÃ©ric Viry, Andreas Podelski and Christian Schilling (2018) &lt;a href=&#34;https://www.hscc2018.deib.polimi.it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HSCC&#39;18&lt;/a&gt; Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control: 41â€“50. See the &lt;a href=&#34;http://dx.doi.org/10.1145/3178126.3178128&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ACM Digital Library link&lt;/a&gt;, or the &lt;a href=&#34;https://arxiv.org/abs/1801.09526&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;arXiv: 1801.09526&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Approximating the set of reachable states of a dynamical system is an
algorithmic yet mathematically rigorous way to reason about its safety.
Although progress has been made in the development of efficient algorithms
for affine dynamical systems, available algorithms still lack scalability
to ensure their wide adoption in the industrial setting. While modern
linear algebra packages are efficient for matrices with tens of thousands
of dimensions, set-based image computations are limited to a few hundred.
We propose to decompose reach set computations such that set operations
are performed in low dimensions, while matrix operations like exponentiation
are carried out in the full dimension. Our method is applicable both in dense
and discrete-time settings. For a set of standard benchmarks, it shows a
speed-up of up to two orders of magnitude compared to the respective
state-of-the-art tools, with only modest losses in accuracy.
For the dense-time case, we show an experiment with more than 10,000
variables, roughly two orders of magnitude higher than possible with previous
approaches.&lt;/p&gt;
&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;
&lt;p&gt;We present a new method to solve the reachability
problem for affine dynamical systems with nondeterministic inputs
and experimentally show that it is highly scalable under modest
loss of accuracy.&lt;/p&gt;
&lt;p&gt;More precisely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We provide a new decomposition approach to solve the set-based recurrence:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathcal{X}(k+1) = \Phi \mathcal{X}(k) \oplus \mathcal{V}(k),\qquad k = 0, 1,\ldots, N
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We analyze the approximation error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We address both the dense time and the discrete time reach-
ability problem for general linear time-invariant systems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We implement our approach efficiently and demonstrate its
scalability on real engineering benchmarks. The tool, source
code, and benchmark scripts are publicly available.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-cite&#34;&gt;How to cite&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@inproceedings{bogomolov2018reach,
  title={Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices},
  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Viry, Fr{\&#39;e}d{\&#39;e}ric and Podelski, Andreas and Schilling, Christian},
  booktitle={Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week)},
  pages={41--50},
  year={2018}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
